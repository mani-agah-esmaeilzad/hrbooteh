import { NextRequest, NextResponse } from 'next/server';
import { extractTokenFromHeader, authenticateToken } from '@/lib/auth';
import { chatRequestSchema } from '@/lib/validation';
import {
  getIndependenceQuestionnaireData,
  generateFinalAnalysis
} from '@/lib/ai-utils';
import { getConnectionWithRetry } from '@/lib/database';

// ÿ™ÿßÿ®ÿπ ÿ™ÿ≠ŸÑ€åŸÑ Ÿæÿßÿ≥ÿÆ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å
async function analyzeUserResponse(message: string, dimensions: any[], questionnaireData: any) {
  try {
    console.log('üîç Analyzing message for dimensions:', dimensions);
    const analysisResults = dimensions.map(dimensionId => {
      const dimensionKeywords = questionnaireData.analysis_keywords[dimensionId];
      if (!dimensionKeywords) {
        return {
          dimension: `dimension_${dimensionId}`,
          score: 0,
          reasoning: `⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿ®ÿπÿØ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.`
        };
      }

      const lowerCaseMessage = message.toLowerCase();
      const agreeMatch = dimensionKeywords.agree.some((keyword: string) => lowerCaseMessage.includes(keyword));
      const disagreeMatch = dimensionKeywords.disagree.some((keyword: string) => lowerCaseMessage.includes(keyword));

      let score = 0;
      let reasoning = "Ÿæÿßÿ≥ÿÆ ⁄©ÿßÿ±ÿ®ÿ± ÿÆŸÜÿ´€å €åÿß ŸÜÿßŸÖÿ¥ÿÆÿµ ÿ®ŸàÿØ.";

      if (agreeMatch && !disagreeMatch) {
        score = 2;
        reasoning = "⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿß€åŸÜ ÿ®ÿπÿØ ŸÖŸàÿßŸÅŸÇÿ™ ⁄©ÿ±ÿØ.";
      } else if (disagreeMatch && !agreeMatch) {
        score = 1;
        reasoning = "⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿß€åŸÜ ÿ®ÿπÿØ ŸÖÿÆÿßŸÑŸÅÿ™ ⁄©ÿ±ÿØ.";
      }

      // ÿßÿπŸÖÿßŸÑ ÿßŸÖÿ™€åÿßÿ≤ÿØŸá€å ŸÖÿπ⁄©Ÿàÿ≥ ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜ€åÿßÿ≤
      const reverseScoredIds = [1, 3, 5];
      if (reverseScoredIds.includes(dimensionId)) {
        if (score === 2) score = 1;
        else if (score === 1) score = 2;
      }
      
      return {
        dimension: `dimension_${dimensionId}`,
        score: score,
        reasoning: reasoning
      };
    });

    return analysisResults;
  } catch (error) {
    console.error('‚ùå Analysis error:', error);
    return [];
  }
}

export async function POST(request: NextRequest) {
  let connection = null;
  
  try {
    console.log('üöÄ === STARTING INDEPENDENCE CHAT API ===');

    // === Authentication ===
    const authHeader = request.headers.get('authorization');
    const token = extractTokenFromHeader(authHeader || undefined);

    if (!token) {
      console.error('‚ùå No token provided');
      return NextResponse.json(
        { success: false, message: 'ÿ™Ÿà⁄©ŸÜ ÿßÿ≠ÿ±ÿßÿ≤ ŸáŸà€åÿ™ ÿßÿ±ÿßÿ¶Ÿá ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™' },
        { status: 401 }
      );
    }

    let decodedToken;
    try {
      decodedToken = authenticateToken(token);
      console.log('‚úÖ Token decoded successfully. UserID:', decodedToken?.userId);
    } catch (authError: any) {
      console.error('‚ùå Token authentication failed:', authError.message);
      return NextResponse.json(
        { success: false, message: 'ÿ™Ÿà⁄©ŸÜ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± €åÿß ŸÖŸÜŸÇÿ∂€å ÿ¥ÿØŸá ÿßÿ≥ÿ™' },
        { status: 401 }
      );
    }

    // === Request Validation ===
    console.log('üì¶ Parsing request body...');
    let body;
    try {
      body = await request.json();
      console.log('üìã Request body:', { 
        hasMessage: !!body?.message, 
        hasSessionId: !!body?.session_id,
        messageLength: body?.message?.length || 0,
        bodyKeys: Object.keys(body || {})
      });
    } catch (parseError: any) {
      console.error('‚ùå JSON parse failed:', parseError.message);
      return NextResponse.json(
        { success: false, message: 'ÿÆÿ∑ÿß ÿØÿ± ÿÆŸàÿßŸÜÿØŸÜ ÿØÿßÿØŸá‚ÄåŸáÿß€å Ÿàÿ±ŸàÿØ€å' },
        { status: 400 }
      );
    }

    const validationResult = chatRequestSchema.safeParse(body);
    if (!validationResult.success) {
      console.error('‚ùå Validation failed:', validationResult.error.errors);
      return NextResponse.json(
        { 
          success: false, 
          message: 'ÿØÿßÿØŸá‚ÄåŸáÿß€å Ÿàÿ±ŸàÿØ€å ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™',
          debug: validationResult.error.errors
        },
        { status: 400 }
      );
    }

    const { message, session_id } = validationResult.data;
    const userId = decodedToken.userId;
    console.log(`üë§ Validated - UserID: ${userId}, Session: ${session_id}`);

    // === Questionnaire Data ===
    console.log('üìö Loading questionnaire data...');
    const questionnaireData = getIndependenceQuestionnaireData();
    if (!questionnaireData?.scenario_parts?.length) {
      console.error('‚ùå Questionnaire data invalid');
      return NextResponse.json(
        { success: false, message: 'ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿØÿßÿØŸá‚ÄåŸáÿß€å Ÿæÿ±ÿ≥ÿ¥ŸÜÿßŸÖŸá' },
        { status: 500 }
      );
    }
    console.log('‚úÖ Questionnaire loaded. Parts:', questionnaireData.scenario_parts.length);

    // === Database Connection ===
    console.log('üóÑÔ∏è Connecting to database...');
    connection = await getConnectionWithRetry();
    if (!connection) {
      console.error('‚ùå Database connection failed');
      return NextResponse.json(
        { success: false, message: 'ÿÆÿ∑ÿß ÿØÿ± ÿßÿ™ÿµÿßŸÑ ÿ®Ÿá ÿØ€åÿ™ÿßÿ®€åÿ≥' },
        { status: 500 }
      );
    }

    // === Fetch User Data ===
    let userName = '⁄©ÿßÿ±ÿ®ÿ±';
    try {
      const [users] = await connection.execute(
        'SELECT first_name, last_name FROM users WHERE id = ?',
        [userId]
      );
      const userData = Array.isArray(users) && users.length > 0 ? users[0] as any : null;
      userName = userData ? `${userData.first_name || ''} ${userData.last_name || ''}`.trim() : '⁄©ÿßÿ±ÿ®ÿ±';
      console.log('‚úÖ User data fetched:', userName);
    } catch (error) {
      console.error('‚ö†Ô∏è Failed to fetch user data:', error);
    }

    // === Find or Create Assessment ===
    console.log('üìã Finding/creating assessment...');
    let assessment;
    try {
      const questionnaireId = 1; // Hardcoded for Independence assessment
      
      console.log(`[DEBUG] Searching for active assessment for user_id: ${userId}, questionnaire_id: ${questionnaireId}`);
      const [assessments] = await connection.execute(
        'SELECT * FROM assessments WHERE user_id = ? AND questionnaire_id = ? AND completed_at IS NULL ORDER BY created_at DESC LIMIT 1',
        [userId, questionnaireId]
      );
      
      if (!Array.isArray(assessments) || assessments.length === 0) {
        console.log('‚ö†Ô∏è No active assessment found. Creating a new one.');
        const [result] = await connection.execute(
          'INSERT INTO assessments (user_id, questionnaire_id, score, created_at) VALUES (?, ?, ?, NOW())',
          [userId, questionnaireId, 0]
        );
        const newAssessmentId = (result as any).insertId;
        const [newAssessments] = await connection.execute('SELECT * FROM assessments WHERE id = ?', [newAssessmentId]);
        assessment = (newAssessments as any[])[0];
      } else {
        assessment = assessments[0] as any;
        console.log('‚úÖ Found existing active assessment:', assessment.id);
      }
    } catch (assessmentError: any) {
      console.error('‚ùå Assessment handling failed:', assessmentError.message);
      return NextResponse.json(
        { success: false, message: 'ÿÆÿ∑ÿß ÿØÿ± ŸÖÿØ€åÿ±€åÿ™ ÿßÿ±ÿ≤€åÿßÿ®€å' },
        { status: 500 }
      );
    }

    let currentScore = assessment.score || 0;
    console.log('üìä Current score:', currentScore);

    // === Save User Message ===
    console.log('üí¨ Saving user message...');
    try {
      await connection.execute(
        'INSERT INTO chat_messages (assessment_id, user_id, message_type, content, character_name) VALUES (?, ?, ?, ?, ?)',
        [assessment.id, userId, 'user', message, 'User']
      );
      console.log('‚úÖ User message saved.');
    } catch (saveError: any) {
      console.error('‚ùå Failed to save user message:', saveError.message);
      return NextResponse.json(
        { success: false, message: 'ÿÆÿ∑ÿß ÿØÿ± ÿ∞ÿÆ€åÿ±Ÿá Ÿæ€åÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ±' },
        { status: 500 }
      );
    }

    // === Calculate Position ===
    console.log('üßÆ Calculating position...');
    let responseCount, answeredQuestionIndex;
    try {
      const [userResponses] = await connection.execute(
        'SELECT COUNT(*) as count FROM chat_messages WHERE assessment_id = ? AND message_type = ?',
        [assessment.id, 'user']
      );
      responseCount = (userResponses as any)[0].count;
      answeredQuestionIndex = responseCount - 1;
      console.log('üìä Position calculated:', { responseCount, answeredQuestionIndex });
    } catch (countError: any) {
      console.error('‚ùå Failed to count responses:', countError.message);
      return NextResponse.json(
        { success: false, message: 'ÿÆÿ∑ÿß ÿØÿ± ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ŸÖÿ±ÿ≠ŸÑŸá' },
        { status: 500 }
      );
    }

    // === Analyze Response ===
    const currentPart = questionnaireData.scenario_parts[answeredQuestionIndex];
    const dimensionsToAnalyze = currentPart?.dimensions_to_analyze || [];
    
    let analysis = [];
    if (dimensionsToAnalyze.length > 0) {
      try {
        analysis = await analyzeUserResponse(message, dimensionsToAnalyze, questionnaireData);
        console.log('‚úÖ Analysis completed:', analysis);
      } catch (error) {
        console.error('‚ùå Analysis failed:', error);
      }
    }

    // === Update Score ===
    let scoreIncrease = 0;
    if (Array.isArray(analysis)) {
      for (const result of analysis) {
        if (result && typeof result.score === 'number' && !isNaN(result.score)) {
          scoreIncrease += result.score;
        }
      }
    }
    currentScore += scoreIncrease;

    try {
      await connection.execute(
        'UPDATE assessments SET score = ? WHERE id = ?',
        [currentScore, assessment.id]
      );
      console.log('‚úÖ Score updated:', currentScore);
    } catch (error) {
      console.error('‚ùå Score update failed:', error);
    }

    // === Check Completion ===
    const nextPartIndex = answeredQuestionIndex + 1;
    console.log('üèÅ Checking completion...', { nextPartIndex, totalParts: questionnaireData.scenario_parts.length });
    
    if (nextPartIndex >= questionnaireData.scenario_parts.length) {
      // === Final Analysis ===
      console.log('üéØ Generating final analysis...');
      
      const finalAnalysis = generateFinalAnalysis(currentScore, {}, questionnaireData);
      const level = finalAnalysis.analysis.assessment?.level || 'ŸÜÿßŸÖÿ¥ÿÆÿµ';
      const description = finalAnalysis.analysis.assessment?.description || 'ÿ™ÿ≠ŸÑ€åŸÑ ÿ™⁄©ŸÖ€åŸÑ ÿ¥ÿØ';
      
      try {
        await connection.execute(
          'UPDATE assessments SET level = ?, description = ?, completed_at = NOW() WHERE id = ?',
          [level, description, assessment.id]
        );
        console.log('‚úÖ Final analysis saved');
      } catch (error) {
        console.error('‚ùå Failed to save final analysis:', error);
      }
      
      return NextResponse.json({
        success: true,
        message: 'ÿßÿ±ÿ≤€åÿßÿ®€å ÿ™⁄©ŸÖ€åŸÑ ÿ¥ÿØ',
        data: {
          type: "final_analysis",
          messages: [{
            character: "HR Bot",
            content: `ÿ™ÿ≠ŸÑ€åŸÑ ŸÜŸáÿß€å€å ÿ¥ŸÖÿß ÿ¢ŸÖÿßÿØŸá ÿßÿ≥ÿ™: ${description}`
          }],
          analysis: finalAnalysis,
          session_id: session_id,
        }
      });
    } else {
      // === Continue Scenario ===
      console.log('‚û°Ô∏è Continuing to next part...', nextPartIndex);
      
      const nextPart = questionnaireData.scenario_parts[nextPartIndex];
      const dialogue = nextPart.dialogue.map((item: any) => ({
        ...item,
        content: item.content.replace(/{user_name}/g, userName)
      }));

      // === Save AI Messages ===
      console.log('ü§ñ Saving AI messages...');
      try {
        for (const item of dialogue) {
          await connection.execute(
            'INSERT INTO chat_messages (assessment_id, user_id, message_type, content, character_name) VALUES (?, ?, ?, ?, ?)',
            [assessment.id, userId, 'ai', item.content, item.character]
          );
        }
        console.log('‚úÖ AI messages saved.');
      } catch (aiSaveError: any) {
        console.error('‚ùå Failed to save AI messages:', aiSaveError.message);
      }

      console.log('‚úÖ === SENDING NEXT PART ===');
      return NextResponse.json({
        success: true,
        message: 'ÿ®ÿÆÿ¥ ÿ®ÿπÿØ€å ÿ≥ŸÜÿßÿ±€åŸà ÿ¥ÿ±Ÿàÿπ ÿ¥ÿØ',
        data: {
          type: "ai_turn",
          messages: dialogue,
          current_score: currentScore,
          session_id: session_id,
          current_part: nextPartIndex
        }
      });
    }

  } catch (error: any) {
    console.error('üí• === CRITICAL ERROR ===');
    console.error('Error message:', error.message);

    return NextResponse.json(
      { 
        success: false, 
        message: 'ÿÆÿ∑ÿß€å ÿ≥ÿ±Ÿàÿ±. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ',
        debug: process.env.NODE_ENV === 'development' ? {
          message: error.message
        } : undefined
      },
      { status: 500 }
    );
  } finally {
    if (connection) {
      try {
        console.log('üîí Releasing connection...');
        connection.release();
      } catch (error) {
        console.error('‚ùå Connection release failed:', error);
      }
    }
  }
}

export async function GET() {
  return NextResponse.json({
    message: 'Chat Independence API is available',
    timestamp: new Date().toISOString()
  });
}